<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>SOF3</title>
    <link rel="stylesheet" href="styles.css">
    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link href="https://fonts.googleapis.com/css2?family=Lato&display=swap" rel="stylesheet">
    <link rel="icon" href="images/icon.png">
</head>
<body>
    <div class="container"> <!-- divs can be used to apply styles (in css) to sections of code-->
        <div class="nav-wrapper">
            <div class="left-side">
                <div class="nav-link-wrapper">
                    <a href="index.html">Home</a>
                   
                </div>
                <div class="nav-link-wrapper">
                    <a href="about.html">About</a>
                </div>
                <div class="nav-link-wrapper">
                    <a href="cs_degree.html">CS Degree Stuff</a>
                </div>
            </div>
            <div class="right-side">
                <div class="brand">
                    <div> JONATHAN DAVIES</div> <!-- By themselves, div's only function is a line break-->
                </div>
            </div>
        </div>
        <div class="content-wrapper">
            <div class="sidenav">
                <a href="#block1">Principles of Computer Design</a>

            </div>
            <div class="text-wrapper">
                <div class="module-header">
                    <h1>Software 3</h1>
                    <h2>Credits: 10</h2>
                    <h2><a href="https://www.york.ac.uk/students/studying/manage/programmes/module-catalogue/module/COM00018I/2020-21"> Module Description</a></h2>
                </div>
                <div class="module-topics-wrapper">
                    <div class="list-of-topics">
                        <h2>Topics:</h2>
                        <ul>
                            <li style="color: rgb(255, 166, 0)"> 
                                Block 1 - Intro to functions
                                <ul>
                                    <li>Why functional programming?</li>
                                    <li>Defining functions</li>
                                    <li>Thinking recursively</li>
                                    <li>Haskell type system</li>
                                    <li >Notes on Block 1</li>
                                </ul>
                            </li>
                            <li style="color: rgb(255, 136, 0)">
                                Block 2 - Lists and more functions
                                <ul>
                                    <li>Lambda calculus</li>
                                    <li>List comprehension</li>
                                    <li>Folding lists</li>
                                    <li>Lazy evaluation</li>
                                    <li>Notes on Block 2</li>
                                </ul>
                            </li>
                            <li style="color: rgb(255, 0, 0)">
                                Block 3 - Reasoning and type classes
                                <ul>
                                    <li>Reasoning about programs</li>
                                    <li>Type classes</li>
                                </ul>
                            </li>
                            <li style="color: rgb(255, 0, 0)">
                                Block 4 - IO & Monads
                                <ul>
                                    <li>Effects through monads</li>
                                    <li>Fresh identifier generation using monads</li>
                                </ul>
                            </li>
                        </ul>
                    </div>
                    <div class="block1">
                        <h2 id="block1">
                            Block 1 - Intro to functions
                        </h2>
                        <h3>Why FP?</h3>
                        There are a number of reasons why functional programming languages excel over regular:
                        <ol>
                            <li>
                                Value Orientation: the language is <b>value-oriented</b> meaning all occurences of a name refer to the same value. This is also called being 
                                <b>referentially transparent</b>. It means that it's easier to argue about the results of programs, as you can use equational reasoning. It also means that 
                                it's easy to encode many useful algebraic structures in the libraries, due to the simple mathematical structure.
                                These languages are also called <b>pure</b> due to the lac of ad hoc side effects.
                            </li>
                            <li>
                                All values are first class: this means that functions themselves are treated like any other value, so functions can have functions arguments and function results.
                                It means we can easily abstract away computations and computational structures, and instantiate them as necessary, leading to shorter and better structured code.
                            </li>
                            <li>
                                Laziness for better modularity: the language is <b>lazy</b>, which means all functions are 'call-by-need'. It is an evaluation strategy that only evaluates an expression
                                when it is needed, and only the part that is needed, allowing us to seperate control and data in new ways. Only pure languages can be lazy.
                            </li>
                            <li>
                                Powerful type systems: some languages can optionally have statically decidable type systems. Type systems can protect programmers from a large number of errors, at cost of some 
                                freedom to the programmer. Functional lanuages have very powerful but flexible type systems. Haskell uses a statically decidable type system, giving lots of 
                                protection with little loss of freedom.
                            </li>
                            <li>
                                Difference: the feautures of Haskell makes it a very different language to traditionally learned OOP languages. It allows us to have a deeper understanding of programming 
                                and pprogramming languages, and give us new ways of seeing and solving problems.
                            </li>
                        </ol>
                        <h3>Notes on block 1</h3>
                        <h4>Cons (:) vs concatenate (++)</h4>
                        <p>
                            Seemingly, : and ++ seem to function the same. However, cons prepends a given item to a list e.g. 5:[] = [5]. 
                            Conccatenate, on the other hand, adds a list (on the right) to the end of the list (on the left) e.g. [1,2] ++ [3] = [1,2,3]. 
                            The differences are that cons takes a list element and a list, whereas concatenate takes two lists and joins them together. 
                        </p>
                    </div>
                    <div class="block2">
                        <h2 id="block2">
                            Block 2 - Lists and more functions
                        </h2>
                        <h3>Notes on block 2</h3>
                        <h4>Using the function 'filter'</h4>
                        <p>
                            If we want to select some elements from a list depending on some condition, we can use 'filter'. Syntax is filter (condition) (list). 
                        </p>
                        <h4>Monads</h4>
                        <p>
                            A monad is just a monoid in the category of endofunctors, what's the problem?
                        </p>
                        <p>
                            Seriously though, monads are simply a way of performing side effects without destroying the purity of the language. They cleanly seperate 
                            side-effecting computations with those that don't have side effects, so neither computation interferes with the other.
                            <br>
                            <b>Monads are a generalization of functions, function application, and function composition to allow them to deal with richer notions of computation than standard functions.</b>
                            <br>
                            An example of a monad is the monadic type and function 'Maybe' and 'maybe'. Monadic values are not intuitive, they are just ways of represnting the output of a monadic function. 
                            The maybe function can error check at the same time as performing a function (see question 2.2)
                        </p>
                    </div>
                    <div class="block3">
                        <h3>Notes on Block 3</h3>
                        <h4>type vs newtype vs data</h4>
                        <p>
                            newtype and data are very similar and the differences are only in run-time compiling, when data is treated as a completely new type, whereas a newtype is indistuinshable (i.e. same structure) 
                            from the type it uses. 
                        </p>
                        <p>
                            'type' is just a way to create type synonyms, and is exactly the same of the type it uses at runtime.
                        </p>
                    </div>
            </div>

        </div>
    </div>
</body>
</html>